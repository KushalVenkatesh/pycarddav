#!/usr/bin/env python
# coding: utf-8
# vim: set ts=4 sw=4 expandtab sts=4:
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <geier@lostpackets.de> wrote this file. As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return Christian Geier
# ----------------------------------------------------------------------------


##############################
# imports {{{

#from IPython.Debugger import Tracer; debug_here = Tracer()
import StringIO
import sys
import argparse
import signal
from os import path

from ConfigParser import SafeConfigParser

try:
    import vobject
except ImportError:
    print "py-vobject not installed"
    sys.exit(1)

try:
    import lxml.etree as ET
except:
    print "py-lxml not installad"
    sys.exit(1)

try:
    import pycurl
except:
    print "pycurl not installed"
    sys.exit(1)


try:
    import sqlite3
except:
    print "pysqlite3 not installed"
    sys.exit(1)

# /imports
###########################}}}


def smartencode(s):
    unicode(s).encode("utf-8", "strict")



def checkNewEtag(vRef, vEtag):
    """returns True when the etag has been updated, otherwise False"""
    conn = sqlite3.connect(dbPath)
    c = conn.cursor()
    t = (vRef,)
    c.execute('SELECT etag FROM vcardtable WHERE href=(?);',t)
    if vEtag==c.fetchall()[0][0]:
        returnCode=False
    else:
        returnCode=True
    conn.commit()
    c.close()
    return returnCode

def checkVRefExists(vRef):
    conn = sqlite3.connect(dbPath)
    c = conn.cursor()
    t=(vRef,)
    c.execute('SELECT count(*) FROM vcardtable WHERE href=(?);',t)
    if c.fetchall()==[(1,)]:
        returnCode=False
    else:
        returnCode=True
    conn.commit()
    c.close()
    return returnCode

def insertVRef(vRef):
    """inserts vRef into the vcardtable"""
    conn = sqlite3.connect(dbPath)
    c = conn.cursor()
    t =(vRef,)
    c.execute('INSERT INTO vcardtable (href) VALUES (?);', t)
    conn.commit()
    c.close()

def updateEtag(vRef, vEtag):
    conn = sqlite3.connect(dbPath)
    c = conn.cursor()
    t =(vEtag,vRef,)
    c.execute('UPDATE vcardtable SET etag=(?) WHERE href=(?);',t)
    conn.commit()
    c.close()
    return True

def insertName(vRef,name):
    conn = sqlite3.connect(dbPath)
    c = conn.cursor()
    t =(name, vRef)
    c.execute('UPDATE vcardtable SET name=(?) WHERE href=(?)',t) 
    conn.commit()
    c.close()

def deleteVcardFromDb(vRef):
    conn = sqlite3.connect(dbPath)
    c = conn.cursor()
    t =(vRef,)
    c.execute('DELETE from properties WHERE href=(?)',t) 
    conn.commit()
    c.close()

def getVcard(vRef):
    response=StringIO.StringIO()
    header=StringIO.StringIO()
    c = pycurl.Curl()
    c.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_SSLv3)
    c.setopt(pycurl.WRITEFUNCTION, response.write)
    c.setopt(pycurl.HEADERFUNCTION, header.write)
    c.setopt(pycurl.USERPWD, user+":"+passwd)
    c.setopt(pycurl.URL, baseUrl+vRef)
    if (insecureSSL == 1):
        c.setopt(pycurl.SSL_VERIFYPEER, 0)
    c.perform()
    c.close

    header =  header.getvalue()
    vCard = response.getvalue()
    if (header.find("addressbook") == -1):
        print "URL is not a CardDAV resource"
        sys.exit(1)

    return vCard

def insertVcardInDb(vRef,v):
    if v.name == "VCARD":
        v.prettyPrint()
        for line in v.getChildren():
            try:
                line.transformFromNative()
            except:
                pass

            propertyName = line.name
            propertyValue = line.value
            if (propertyName == "PHOTO"): # for now, we cannot handle photos
                pass
            else:
                conn = sqlite3.connect(dbPath)
                c = conn.cursor()
                t =(unicode(propertyName), unicode(propertyValue),vRef,)

                c.execute('INSERT INTO properties (property, value, href) VALUES (?,?,?);', t)
                lastrowid = c.lastrowid
                if line.params:
                    for key in line.params.keys():
                        for keyValue in line.params[key]:
                            t =(key, keyValue,vRef,lastrowid)
                            c.execute('INSERT INTO parameters (parameter, value, href,property_id) VALUES (?,?,?,?);', t)
                            #print key + ": " + i
                conn.commit()
                c.close()
    else:
        return -1 # this is not a vcard


def signal_handler(signal, frame):
    sys.exit(0)

class PyCardDAV:
    def __init__(self):
        self.debug = ""
        self.user = ""
        self.passwd = ""
        self.resource = ""
        self.base_url = ""
        self.insecure_ssl = 0

    def get_abook(self):
        xml = self._get_xml_props()
        abook = self._process_xml_props(xml)
        return abook

    def _get_xml_props(self):
        response=StringIO.StringIO()
        header=StringIO.StringIO()
        curl = pycurl.Curl()
        curl.setopt(pycurl.WRITEFUNCTION, response.write)
        curl.setopt(pycurl.HEADERFUNCTION, header.write)
        curl.setopt(pycurl.USERPWD, self.user+":"+self.passwd)
        curl.setopt(pycurl.URL, self.resource)
        if (self.insecure_ssl == 1):
            curl.setopt(pycurl.SSL_VERIFYPEER, 0)
        curl.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_SSLv3)
        curl.setopt(pycurl.CUSTOMREQUEST, "PROPFIND")
        curl.perform()
        curl.close
        header = header.getvalue()
        xml = response.getvalue()
        if (header.find("addressbook") == -1):
            print "URL is not a CardDAV resource"
            sys.exit(1)
        return xml

    def _process_xml_props(self, xml):
        namespace="{DAV:}"
        element = ET.XML(xml)
        abook = dict()
        for response in element.iterchildren():
            if (response.tag == namespace+"response"):
                href = ""
                etag = ""
                insert = False
                for refprop in response.iterchildren():
                    if (refprop.tag == namespace+"href"):
                        href = refprop.text
                    for prop in refprop.iterchildren():
                        for props in prop.iterchildren():
                            if (props.tag == namespace+"getcontenttype" and props.text == "text/vcard"):
                                insert = True
                            if (props.tag == namespace+"getetag"):
                                etag = props.text
                            #print("%s - %s" % (props.tag, props.text))
                        if insert:
                            abook[href] = etag
        return abook

class DbTool:
    def __init__(self):
        self.db_path = ""
        self.debug = 0

    def make_tables(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute('''CREATE TABLE version ( version INTEGER )''')
            if self.debug:
                print "created version table"
        except sqlite3.OperationalError as detail:
            if self.debug:
                print detail
        except:
                sys.stderr.write('Failed to connect to database, Unknown Error')
        conn.commit()
        # VERSION information
        t = (2,) # database version db Version
        cursor.execute('INSERT INTO version (version) VALUES (?)',t)
        conn.commit()
        try:
            cursor.execute('''CREATE TABLE vcardtable (
                    href TEXT PRIMARY KEY NOT NULL,
                    etag TEXT,
                    name TEXT,
                    edited INT
                    )''')
            if self.debug:
                print "created vcardtable"
        except sqlite3.OperationalError as detail:
            if self.debug:
                print detail
        except:
                sys.stderr.write('Failed to connect to database, Unknown Error')
        conn.commit()
        # properties table
        try:
                cursor.execute('''CREATE TABLE properties (
                id INTEGER PRIMARY KEY NOT NULL,
                property TEXT NOT NULL,
                value TEXT,
                href TEXT NOT NULL,
                FOREIGN KEY(href) REFERENCES vcardtable(href)
                )''')
                if self.debug:
                        print "created properties table"
        except sqlite3.OperationalError as detail:
                if self.debug:
                        print detail
        except:
                sys.stderr.write('Failed to connect to database, Unknown Error')
        conn.commit()
        # parameter table
        try:
                cursor.execute('''CREATE TABLE parameters(
                parameter TEXT NOT NULL,
                value TEXT,
                href TEXT NOT NULL,
                property_id INTEGER NOT NULL,
                FOREIGN KEY(href) REFERENCES vcardtable(href),
                FOREIGN KEY(property_id) REFERENCES properties(id)
                )''')
                if self.debug:
                        print "created parameters table"
        except sqlite3.OperationalError as detail:
               if self.debug:
                        print detail
        except:
                sys.stderr.write('Failed to connect to database, Unknown Error')
        conn.commit()
        cursor.close()


def main(argv):
    # trying to hide some ugly python code on pressing Ctrl-C
    signal.signal(signal.SIGINT, signal_handler)

    my_dbtool = DbTool()
    syncer = PyCardDAV()

    configfile="~/.pycard/pycard.conf"
    global user, passwd, resource, baseUrl, insecureSSL, dbPath
    dbPath="~/.pycard/pycard.conf"

    arg_parser = argparse.ArgumentParser(
            description = "syncs the local db to the CardDAV server")
    arg_parser.add_argument(
        "-c", "--config", action = "store", dest = "configfile",
        default = "~/.pycard/pycard.conf",
        help="defaults to ~/.pycard/pycard.conf")
    arg_parser.add_argument("-v", "--version", action = "version", version = "0.3.1")
    arg_parser.add_argument("--debug", action = "store_true", dest = "debug",
            default = "False", help = "enable debugging")
    args = arg_parser.parse_args()
    

    #config file foo
    configfile = path.expanduser(configfile)
    if args.debug:
        print "reading config from ", configfile
    conf_parser = SafeConfigParser()
    conf_parser.read(configfile)
    syncer.user = conf_parser.get('default', 'user')
    syncer.passwd = conf_parser.get('default', 'passwd')
    syncer.resource = conf_parser.get('default', 'resource')
    syncer.baseUrl = conf_parser.get('default', 'base_url')
    syncer.insecure_ssl = conf_parser.getint('default', 'insecure_ssl')
    my_dbtool.db_path = path.expanduser(conf_parser.get('default', 'db_path'))
    my_dbtool.debug = conf_parser.getint('default', 'DEBUG')
    my_dbtool.debug = args.debug #argument overrides config file
    syncer.debug = conf_parser.getint('default', 'DEBUG')
    syncer.debug = args.debug #argument overrides config file
    if my_dbtool.debug:
        print "using remote options:"
        print "  user: ", syncer.user
        print "  passwd: ", syncer.passwd
        print "  resource: ", syncer.resource
        print "  baseUrl: ", syncer.baseUrl
        print "  insecureSSL: ", syncer.insecure_ssl
        print "using local options:"
        print "  dbPath: ", my_dbtool.db_path
        print "\n"

    my_dbtool.make_tables()

    abook = syncer.get_abook()

    for vRef,vEtag  in abook.iteritems():
        if checkVRefExists(vRef):
            insertVRef(vRef)
        
        if checkNewEtag(vRef,vEtag):
            deleteVcardFromDb(vRef)
            if args.debug:
                print "getting ", vRef, " etag: ", vEtag

            vcard = getVcard(vRef)
            v = vobject.readOne(vcard)


            # this is the important part
            try:
                insertVcardInDb(vRef,v)
                updateEtag(vRef, vEtag)
            except Exception, err:
                sys.stderr.write("ERROR: something went wrong while inserting VCard %s into the db" % str(vRef))
                sys.stderr.write('%s\n' % str(err))




if __name__ == "__main__":
    main(sys.argv[1:])

