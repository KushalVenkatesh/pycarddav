#!/usr/bin/env python
# coding: utf-8
# vim: set ts=4 sw=4 expandtab sts=4:
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <geier@lostpackets.de> wrote this file. As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return Christian Geier
# ----------------------------------------------------------------------------


##############################
# imports {{{

#from IPython.Debugger import Tracer; debug_here = Tracer()
import StringIO
import sys
import argparse
import signal
import getpass
from os import path
import ast
import StringIO

from ConfigParser import SafeConfigParser

try:
    import vobject
except ImportError:
    print "py-vobject not installed"
    sys.exit(1)

try:
    import lxml.etree as ET
except:
    print "py-lxml not installad"
    sys.exit(1)

try:
    import pycurl
except:
    print "pycurl not installed"
    sys.exit(1)


try:
    import sqlite3
except:
    print "pysqlite3 not installed"
    sys.exit(1)

# /imports
###########################}}}

def smartencode(string):
    """convert everything to utf-8"""
    return unicode(string).encode("utf-8", "strict")


def signal_handler(signal, frame):
    sys.exit(0)


class PyCardDAV(object):
    """interacts with CardDAV server"""

    def __init__(self):
        self.debug = ""
        self.user = ""
        self.passwd = ""
        self.resource = ""
        self.base_url = ""
        self.insecure_ssl = 0
        self.ssl_cacert_file = None
        self.curl = pycurl.Curl()
        self.response = StringIO.StringIO()
        self.header = StringIO.StringIO()

    def get_abook(self):
        xml = self._get_xml_props()
        abook = self._process_xml_props(xml)
        return abook

    def get_vcard(self, vref):
        """
        pulls vcard from server
        returns vcard
        """
        self._curl_reset()
        self.curl.setopt(pycurl.CUSTOMREQUEST, "GET")
        self.curl.setopt(pycurl.URL, self.base_url+vref)
        self.curl.perform()

        header = self.header.getvalue()
        vcard = self.response.getvalue()
        if (header.find("addressbook") == -1):
            print "URL is not a CardDAV resource"
            sys.exit(1)
        return vcard

    def update_vcard(self, card, vref):
        """
        pushes vcard to the server
        card: vcard as unicode string
         """
        # TODO
        print "uploading your changes..."
        self._curl_reset()
        remotepath = str(self.base_url + vref)

        headers = ["Content-Type: application/plain"]
        self.curl.setopt(pycurl.HTTPHEADER, headers)
        #self.response = StringIO.StringIO()
        #self.header = StringIO.StringIO()
        #self.curl.setopt(pycurl.VERBOSE, 1)
        self.curl.setopt(pycurl.UPLOAD, 1)
        self.curl.setopt(pycurl.URL, remotepath)
        tempfile = StringIO.StringIO(card)
        self.curl.setopt(pycurl.READFUNCTION, tempfile.read)
        self.curl.setopt(pycurl.INFILESIZE, tempfile.len)

        self.curl.perform()
        #cleanup
        #header = self.header.getvalue()
        tempfile.close()
        self.curl.close()

    def _curl_reset(self):
        """
        resets the connection, called from within the other
        functions interacting with the CardDAV server
        """
        self.curl = pycurl.Curl()
        self.response = StringIO.StringIO()
        self.header = StringIO.StringIO()
        self.curl.setopt(pycurl.WRITEFUNCTION, self.response.write)
        self.curl.setopt(pycurl.HEADERFUNCTION, self.header.write)
        self.curl.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_SSLv3)
        self.curl.setopt(pycurl.USERPWD, self.user + ":" + self.passwd)
        if (self.insecure_ssl == 1):
            self.curl.setopt(pycurl.SSL_VERIFYPEER, 0)
        if self.ssl_cacert_file:
            self.curl.setopt(pycurl.CAINFO, path.expanduser(self.ssl_cacert_file))

    def _get_xml_props(self):
        """returns xml (str)"""
        self._curl_reset()
        self.curl.setopt(pycurl.CUSTOMREQUEST, "PROPFIND")
        self.curl.setopt(pycurl.URL, self.resource)
        self.curl.perform()
        header = self.header.getvalue()
        xml = self.response.getvalue()
        if (header.find("addressbook") == -1):
            print "URL is not a CardDAV resource"
            sys.exit(1)
        return xml

    def _process_xml_props(self, xml):
        """returns abook (dict())"""
        namespace = "{DAV:}"
        element = ET.XML(xml)
        abook = dict()
        for response in element.iterchildren():
            if (response.tag == namespace+"response"):
                href = ""
                etag = ""
                insert = False
                for refprop in response.iterchildren():
                    if (refprop.tag == namespace+"href"):
                        href = refprop.text
                    for prop in refprop.iterchildren():
                        for props in prop.iterchildren():
                            if (props.tag == namespace+"getcontenttype" and props.text == "text/vcard"):
                                insert = True
                            if (props.tag == namespace+"getetag"):
                                etag = props.text
                            #print("%s - %s" % (props.tag, props.text))
                        if insert:
                            abook[href] = etag
        return abook


class DbTool(object):
    """interacts with the local db"""

    def __init__(self):
        self.db_path = ""
        self.debug = 0

    def make_tables(self):
        """creates tables, also checks existing tables for version number"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        try:
            cursor.execute('''CREATE TABLE version ( version INTEGER )''')
            if self.debug:
                print "created version table"
        except sqlite3.OperationalError as detail:
            if self.debug:
                print detail
        except Exception, error:
            sys.stderr.write('Failed to connect to database, Unknown Error: ' + str(error)+"\n")
        conn.commit()

        # testing for database version
        database_version = 3
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute('SELECT version FROM version')
            result = cursor.fetchone()
            if result == None:
                stuple = (database_version, ) # database version db Version
                cursor.execute('INSERT INTO version (version) VALUES (?)', stuple)
                conn.commit()
            elif not result[0] == database_version:
                sys.exit(str(self.db_path) + " is probably not a valid or an "
                    "outdated database.\nYou should consider to remove it and "
                    "sync again using pycardsyncer.\n")
        except Exception, error:
            sys.stderr.write('Failed to connect to database, Unknown Error: ' + str(error)+"\n")

        try:
            cursor.execute('''CREATE TABLE vcardtable (
                    href TEXT PRIMARY KEY NOT NULL,
                    etag TEXT,
                    name TEXT,
                    edited INT
                    )''')
            if self.debug:
                print "created vcardtable"
        except sqlite3.OperationalError as detail:
            if self.debug:
                print detail
        except Exception, error:
            sys.stderr.write('Failed to connect to database, Unknown Error: ' + str(error)+"\n")
        conn.commit()
        # properties table
        try:
            cursor.execute('''CREATE TABLE properties (
            id INTEGER PRIMARY KEY NOT NULL,
            property TEXT NOT NULL,
            value TEXT,
            href TEXT NOT NULL,
            parameters TEXT,
            FOREIGN KEY(href) REFERENCES vcardtable(href)
            )''')
            if self.debug:
                print "created properties table"
        except sqlite3.OperationalError as detail:
            if self.debug:
                print detail
        except Exception, error:
            sys.stderr.write('Failed to connect to database, Unknown Error: ' + str(error)+"\n")
        conn.commit()
        cursor.close()

    def check_new_etag(self, vref, v_etag):
        """returns True when the etag has been updated, otherwise False"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        stuple = (vref, )
        cursor.execute('SELECT etag FROM vcardtable WHERE href=(?);', stuple)
        if v_etag == cursor.fetchall()[0][0]:
            return_code = False
        else:
            return_code = True
        conn.commit()
        cursor.close()
        return return_code

    def check_vref_exists(self, vref):
        """
        returns False if vref already exists in db
        returns True otherwise
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        stuple = (vref, )
        cursor.execute('SELECT count(*) FROM vcardtable WHERE href=(?);', stuple)
        if cursor.fetchall() == [(1, )]:
            return_code = False
        else:
            return_code = True
        conn.commit()
        cursor.close()
        return return_code

    def insert_vref(self, vref):
        """
        inserts vref into the vcardtable
        returns nothing
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        stuple = (vref, )
        cursor.execute('INSERT INTO vcardtable (href) VALUES (?);', stuple)
        conn.commit()
        cursor.close()

    def update_etag(self, vref, v_etag):
        """returns nothing"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        stuple = (v_etag, vref)
        cursor.execute('UPDATE vcardtable SET etag=(?) WHERE href=(?);', stuple)
        conn.commit()
        cursor.close()

    def delete_vcard_from_db(self, vref):
        """returns nothing"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        stuple = (vref, )
        cursor.execute('DELETE FROM properties WHERE href=(?)', stuple)
        conn.commit()
        cursor.close()

    def get_all_vref_from_db(self):
        """returns a list with all vrefs"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('SELECT href FROM vcardtable')
        result = cursor.fetchall()
        return [row[0] for row in result]

    def get_vcard_from_db(self, vref):
        """returns a vobject.vCard()"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        stuple = (vref, )
        cursor.execute('SELECT id, property, value, parameters FROM properties WHERE href=(?)', stuple)
        result = cursor.fetchall()

        card = vobject.vCard()
        for uid, prop, value, parameters in result:
            # atm we need to treat N and ADR properties differently #FIXME
            # BUG: ORG should be treated differently, too
            tmp = card.add(prop)
            if prop == u"N":
                name = value.split(";")
                tmp.value = vobject.vcard.Name(family=name[0], given=name[1], additional=name[2], prefix=name[3], suffix=name[4])
            elif prop == u"ADR":
                adr = value.split(";")
                tmp.value = vobject.vcard.Address(street=adr[0], city=adr[1], region=adr[2], code=adr[3], country=adr[4], box=adr[5], extended=adr[6])
            else:
                tmp.value = value
            tmp.params = ast.literal_eval(parameters)
        conn.close()
        #import ipdb; ipdb.set_trace()
        return card

    def get_local_edited_hrefs(self):
        """returns list of hrefs of locally edited vcards"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('SELECT href FROM vcardtable where edited == 1')
        result = cursor.fetchall()
        return [row[0] for row in result]

    def insert_vcard_in_db(self, vref, vcard):
        """
        vcard: vobject.Vcard()
        returns nothing
        """
        if vcard.name == "VCARD":
            for line in vcard.getChildren():
                try:
                    line.transformFromNative()
                except:
                    pass

                property_name = line.name
                property_value = line.value
                # for now, we cannot handle photos (or any other binary data):
                # FIXME
                try:
                    if line.ENCODING_paramlist == [u'b']:
                        print "found binary"
                except:
                    pass
                if (property_name == "PHOTO"):
                    pass
                else:
                    conn = sqlite3.connect(self.db_path)
                    cursor = conn.cursor()
                    stuple = (unicode(property_name), unicode(property_value), vref, unicode(line.params), )
                    #import ipdb; ipdb.set_trace()

                    cursor.execute('INSERT INTO properties (property, value, href, parameters) VALUES (?,?,?,?);', stuple)
                    conn.commit()
                    cursor.close()
        else:
            return -1 # this is not a vcard

    def reset_flag(self, href):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        stuple = (href, )

        cursor.execute('UPDATE vcardtable SET edited = 0 WHERE href = ?', stuple)
        conn.commit()
        conn.close()


def main():
    """this should probably be seperated from the class definitions"""
    # trying to hide some ugly python code on pressing Ctrl-C
    signal.signal(signal.SIGINT, signal_handler)

    my_dbtool = DbTool()
    syncer = PyCardDAV()

    arg_parser = argparse.ArgumentParser(
            description = "syncs the local db to the CardDAV server")
    arg_parser.add_argument(
        "-c", "--config", action = "store", dest = "configfile",
        default = "~/.pycard/pycard.conf",
        help="defaults to ~/.pycard/pycard.conf")
    arg_parser.add_argument("-v", "--version", action = "version", version = "0.3.1")
    arg_parser.add_argument("--debug", action = "store_true", dest = "debug",
            default = "False", help = "enable debugging; WARNING: shows your password in cleartext")
    arg_parser.add_argument("-b", "--backup", action = "store", dest = "backup",
            help = "backup the local db to BACKUP")
    arg_parser.add_argument('-i', '--import', type=argparse.FileType('r'),
            dest = 'importing', help='import vcard from file or STDIN')
    args = arg_parser.parse_args()

    #config file foo
    configfile = path.expanduser(args.configfile)
    if args.debug:
        print "reading config from ", configfile
    conf_parser = SafeConfigParser()
    conf_parser.read(configfile)
    syncer.user = conf_parser.get('default', 'user')
    try:
        syncer.passwd = conf_parser.get('default', 'passwd')
    except:
        syncer.passwd = getpass.getpass(prompt='CardDAV password: ')
    syncer.resource = conf_parser.get('default', 'resource')
    syncer.base_url = conf_parser.get('default', 'base_url')
    my_dbtool.db_path = path.expanduser(conf_parser.get('default', 'db_path'))
    my_dbtool.debug = conf_parser.getint('default', 'DEBUG')
    my_dbtool.debug = args.debug #argument overrides config file
    # ssl:
    try:
        syncer.insecure_ssl = conf_parser.getint('default', 'insecure_ssl')
    except:
        pass
    try:
        syncer.ssl_cacert_file = conf_parser.get('default', 'ssl_cacert_file')
    except:
        pass
    syncer.debug = conf_parser.getint('default', 'DEBUG')
    syncer.debug = args.debug #argument overrides config file

    if my_dbtool.debug:
        print "using remote options:"
        print "  user:", syncer.user
        print "  passwd:", syncer.passwd
        print "  resource:", syncer.resource
        print "  base_url:", syncer.base_url
        print "  insecureSSL:", syncer.insecure_ssl
        print "using local options:"
        print "  db_path:", my_dbtool.db_path
        print "\n"

    my_dbtool.make_tables()

    # backup:
    if args.backup:
        vcf_file = open(args.backup, 'w')
        hreflist = my_dbtool.get_all_vref_from_db()
        for href in hreflist:
            card = my_dbtool.get_vcard_from_db(href)
            vcf_file.write(card.serialize())
        sys.exit()

    #import:
    if args.importing:
        # TODO
        infile = args.importing.readlines()
        vcard = vobject.readOne("".join(infile))
        print vcard
        print "sorry, nothing to see here..."
        import ipdb; ipdb.set_trace()
        sys.exit()

    # sync:
    else:
        abook = syncer.get_abook()

        for vref, v_etag in abook.iteritems():
            if my_dbtool.check_vref_exists(vref):
                my_dbtool.insert_vref(vref)

            if my_dbtool.check_new_etag(vref, v_etag):
                my_dbtool.delete_vcard_from_db(vref)
                if args.debug:
                    print "getting ", vref, " etag: ", v_etag
                vcard = syncer.get_vcard(vref)
                vcard = vobject.readOne(vcard)

                #try:
               # import ipdb; ipdb.set_trace()
                my_dbtool.insert_vcard_in_db(vref, vcard)
                my_dbtool.update_etag(vref, v_etag)
                #except Exception as err:
                #    sys.stderr.write("ERROR: something went wrong while inserting VCard %s into the db\n" % str(vref))
                #    sys.stderr.write('%s\n' % str(err))
        # for now local changes overwritten by remote changes
        print "getting changed vcards from db"
        hrefs = my_dbtool.get_local_edited_hrefs()
        print "got changed vcards from db"
        for href in hrefs:
            print "uploading " + href
            card = my_dbtool.get_vcard_from_db(href)
            syncer.update_vcard(card.serialize(), href)
            my_dbtool.reset_flag(href)


if __name__ == "__main__":
    main()
