#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: set fileencoding=utf-8 ts=4 sw=4 expandtab sts=4:

"""A pyCardDAV tool to create VCards from one email.
"""


import email
import email.header
import os
import sys
import traceback
import urwid
import urwid.curses_display

import pycarddav
import pycarddav.backend
import pycarddav.model


class ImportConfigurationParser(pycarddav.ConfigurationParser):
    """A specialized setup tool for importing a contact."""
    def __init__(self):
        pycarddav.ConfigurationParser.__init__(self, 'Import contacts from a mail on input.')

        self._arg_parser.epilog = 'Only the From header is parsed if no header is specified.'
        self._arg_parser.add_argument(
            '--batch', action='store_true', dest='batch', default=False,
            help='do not open the editor')
        self._arg_parser.add_argument(
            '-n', '--dry-run', action='store_true', dest='dry_run', default=False,
            help='do not actually update the database (implies --batch)')

        # Headers selection. To: is the default.
        self._arg_parser.add_argument(
            '-f', '--from', action='append_const', dest='headers', const='From',
            help='import the content of the From header')
        self._arg_parser.add_argument(
            '-t', '--to', action='append_const', dest='headers', const='To',
            help='import the content of the To header')
        self._arg_parser.add_argument(
            '--cc', action='append_const', dest='headers', const='Cc',
            help='import the content of the Cc header')
        self._arg_parser.add_argument(
            '--bcc', action='append_const', dest='headers', const='Bcc',
            help='import the content of the Bcc header')

    def check(self, conf):
        if conf.dry_run:
            conf.batch = True
        if not conf.headers:
            conf.headers = ['From']

        return pycarddav.ConfigurationParser.check(self, conf)


class VCardWalker(urwid.ListWalker):
    """A walker to browse a VCard list.

    This walker returns a selectable Text for each of the passed VCard
    references. If no references are passed to the constructor, then
    the whole database is browsed.
    """

    class Entry(urwid.Text):
        """A specialized Text which can be used for browsing in a list."""
        _selectable = True

        def keypress(self, _, key):
            return key

    def __init__(self, database, refs=None):
        urwid.ListWalker.__init__(self)
        self._db = database
        self._refs = refs or database.get_all_vref_from_db()
        self._current = 0

    @property
    def selected_vcard(self):
        """Return the focused VCard."""
        return self._db.get_vcard_from_db(self._refs[self._current])

    def get_focus(self):
        """Return (focused widget, focused position)."""
        return self._get_at(self._current)

    def set_focus(self, pos):
        """Focus on pos."""
        self._current = pos
        self._modified()

    def get_next(self, pos):
        """Return (widget after pos, position after pos)."""
        if pos >= len(self._refs) - 1:
            return None, None
        return self._get_at(pos + 1)

    def get_prev(self, pos):
        """Return (widget before pos, position before pos)."""
        if pos <= 0:
            return None, None
        return self._get_at(pos - 1)

    def _get_at(self, pos):
        """Return a textual representation of the VCard at pos."""
        vcard = self._db.get_vcard_from_db(self._refs[pos])
        label = vcard.fname
        if vcard['EMAIL']:
            label += ' (%s)' % vcard['EMAIL'][0][0]
        return urwid.AttrMap(VCardWalker.Entry(label), 'list', 'list focused'), pos


class Pane(urwid.WidgetWrap):
    """An abstract Pane to be used in a Window object."""
    def __init__(self, title, widget):
        urwid.WidgetWrap.__init__(self, widget)
        self.title = title
        self.window = None


class VCardChooserPane(Pane):
    """A VCards chooser.

    This pane allows to browse a list of VCards. If no references are
    passed to the constructor, then the whole database is browsed. A
    VCard can be selected to be used in another pane, like the
    EditorPane.
    """
    def __init__(self, database, refs=None):
        self._walker = VCardWalker(database, refs)
        Pane.__init__(self, 'Browse...', urwid.ListBox(self._walker))

    def keypress(self, size, key):
        self._w.keypress(size, key)
        if key in [' ', 'enter']:
            self.window.backtrack(self._walker.selected_vcard)
        else:
            return key


class EditorPane(Pane):
    """A VCard editor."""
    def __init__(self, database, vcard):
        self._vcard = vcard
        self._db = database

        self._label = vcard.fname if vcard.fname else vcard['EMAIL'][0][0]
        self._fname_edit = urwid.Edit('', '')
        self._lname_edit = urwid.Edit('', '')
        self._email_edits = None

        Pane.__init__(self, 'Edit %s' % vcard.fname, self._build_ui())

    def keypress(self, size, key):
        self._w.keypress(size, key)
        if key == 'f8':
            self._validate()
            self.window.backtrack()
        else:
            return key

    def on_button_press(self, button):
        if button.get_label() == 'Merge':
            self.window.open(VCardChooserPane(self._db), self.on_merge_vcard)
        else:
            if button.get_label() == 'Store':
                self._validate()
            self.window.backtrack()

    def on_merge_vcard(self, vcard):
        # TODO: this currently merges only one email field, which is ok to use with mutt.
        if vcard:
            vcard['EMAIL'].append(self._vcard['EMAIL'][0])
            self._vcard = vcard
            self._w = self._build_ui()

    def _build_ui(self):
        content = []
        content.extend(self._build_names_section())
        content.extend(self._build_emails_section())
        content.extend(self._build_buttons_section())

        return urwid.ListBox(urwid.SimpleListWalker(content))

    def _build_names_section(self):
        names = self._vcard.name.split(';')
        if len(names) > 1:
            self._lname_edit.set_edit_text(names[0])
            self._fname_edit.set_edit_text(names[1])
        else:
            self._lname_edit.set_edit_text('')
            self._fname_edit.set_edit_text(names[0])

        return [urwid.Divider(),
                urwid.Columns([
                    ('fixed', 15, urwid.AttrWrap(urwid.Text(u'First Name'), 'line header')),
                    urwid.AttrWrap(self._fname_edit, 'edit', 'edit focused')]),
                urwid.Divider(),
                urwid.Columns([
                    ('fixed', 15, urwid.AttrWrap(urwid.Text(u'Last Name'), 'line header')),
                    urwid.AttrWrap(self._lname_edit, 'edit', 'edit focused')])]

    def _build_emails_section(self):
        self._email_edits = []
        content = []
        for mail in self._vcard['EMAIL']:
            edit = urwid.Edit('', mail[0])
            self._email_edits.append(edit)
            content.extend([
                urwid.Divider(),
                urwid.Columns([
                    ('fixed', 15, urwid.AttrWrap(urwid.Text(u'Email'), 'line header')),
                    urwid.AttrWrap(edit, 'edit', 'edit focused')])])

        return content

    def _build_buttons_section(self):
        buttons = [u'Cancel', u'Merge', u'Store']
        row = urwid.GridFlow([urwid.AttrWrap(urwid.Button(lbl, self.on_button_press),
                             'button','button focused') for lbl in buttons],
                             10, 3, 1, 'left')
        return [urwid.Divider('-', 1, 1),
                urwid.Padding(row, 'right', 13 * len(buttons), None, 1, 1)]

    def _validate(self):
        self._vcard.fname = ' '.join(
            [self._fname_edit.edit_text, self._lname_edit.edit_text])
        for i, edit in enumerate(self._email_edits):
            self._vcard['EMAIL'][i] = (edit.edit_text, self._vcard['EMAIL'][i][1])
        self._db.update(self._vcard, self._vcard.href)


class Window(urwid.Frame):
    """The main user interface frame.

    A window is a frame which displays a header, a footer and a body.
    The header and the footer are handled by this object, and the body
    is the space where Panes can be displayed.

    Each Pane is an interface to interact with the database in one
    way: list the VCards, edit one VCard, and so on. The Window
    provides a mechanism allowing the panes to chain themselves, and
    to carry data between them.
    """
    PALETTE = [('header', 'white', 'black'),
               ('footer', 'white', 'black'),
               ('line header', 'black', 'white', 'bold'),
               ('list', 'black', 'white'),
               ('list focused', 'white', 'light blue', 'bold'),
               ('edit', 'black', 'white'),
               ('edit focused', 'white', 'light blue', 'bold'),
               ('button', 'black', 'dark cyan'),
               ('button focused', 'white', 'light blue', 'bold')]

    def __init__(self):
        self._track = []
        self._title = u' %s v.%s' % (pycarddav.__productname__, pycarddav.__version__)

        header = urwid.AttrWrap(urwid.Text(self._title), 'header')
        footer = urwid.AttrWrap(urwid.Text(
            u' Use Up/Down/PgUp/PgDown to scroll. Esc to return.'), 'footer')
        urwid.Frame.__init__(self, urwid.Text(''), header=header, footer=footer)

    def open(self, pane, callback=None):
        """Open a new pane.

        The given pane is added to the track and opened. If the given
        callback is not None, it will be called when this new pane
        will be closed.
        """
        pane.window = self
        self._track.append((pane, callback))
        self._update(pane)

    def backtrack(self, data=None):
        """Unstack the displayed pane.

        The current pane is discarded, and the previous one is
        displayed. If the current pane was opened with a callback,
        this callback is called with the given data (if any) before
        the previous pane gets redrawn.
        """
        _, cb = self._track.pop()
        if cb:
            cb(data)

        if self._track:
            self._update(self._track[-1][0])
        else:
            raise urwid.ExitMainLoop()

    def on_key_press(self, key):
        """Handle application-wide key strokes."""
        if key == 'esc':
            self.backtrack()

    def _update(self, pane):
        self.header.w.set_text(u'%s | %s' % (self._title, pane.title))
        self.set_body(pane)


class MailParser(object):
    def __init__(self, conf, pipe):
        self._conf = conf
        self._db = pycarddav.backend.SQLiteDb(
            conf.sqlite__path, "utf-8", "stricts", False)
        self._msg = email.message_from_string(pipe.read())

    def process_addresses(self, headers):
        for header in headers:
            address, display_name = self.parse_address(self._msg[header])
            if address is None:
                continue
            vcard = pycarddav.model.vcard_from_email(display_name, address)
            if self._conf.batch:
                if not self._conf.dry_run:
                    self._db.update(vcard, vcard.href)
            else:
                frame = Window()
                frame.open(EditorPane(self._db, vcard))
                loop = urwid.MainLoop(frame, Window.PALETTE,
                                      unhandled_input=frame.on_key_press)
                loop.run()

    def parse_address(self, header):
        if header is None:
            return None, ''

        address_string = []
        addresses = email.header.decode_header(header)
        for string, enc in addresses:
            try:
                string = string.decode(enc)
            except TypeError:
                string = unicode(string)
            address_string.append(string)

        address_string = ' '.join(address_string)
        display_name, address = email.utils.parseaddr(address_string)

        return address, display_name


def capture_tty():
    """Walk the parent processes until a TTY is found.

    See http://stackoverflow.com/questions/1728330/how-to-get-processs-grandparent-id
    """
    pid = 'self'
    input_file = sys.stdin
    while not input_file.isatty():
        input_file.close()

        if pid == 1:
            raise RuntimeError, 'cannot find a TTY'

        with open('/proc/%s/status' % pid) as f:
            for line in f:
                if line.startswith('PPid:'):
                    _, _, pid = line.rpartition("\t")
                    pid = pid.rstrip()
                    input_file = open('/proc/%s/fd/0' % pid)
                    break
            else:
                raise RuntimeError, 'cannot find parent of %s' % pid

    if pid != 'self':
        sys.stdin = input_file
        sys.stdout = open('/proc/%s/fd/1' % pid, 'wb')
        sys.stderr = open('/proc/%s/fd/2' % pid, 'wb')

        os.dup2(sys.stdin.fileno(), 0)
        os.dup2(sys.stdout.fileno(), 1)
        os.dup2(sys.stderr.fileno(), 2)


def release_tty():
    sys.stdin.close()
    sys.stdout.close()
    sys.stderr.close()


if __name__ == '__main__':
    conf = ImportConfigurationParser().parse()
    if conf is None:
        sys.exit(1)

    parser = MailParser(conf, sys.stdin)

    if not conf.batch:
        capture_tty()
    try:
        parser.process_addresses(conf.headers)

    except Exception:
        exc_type, exc_value, exc_tb = sys.exc_info()
        traceback.print_exception(exc_type, exc_value, exc_tb, file=sys.stdout)
    finally:
        if not conf.batch:
            release_tty()
